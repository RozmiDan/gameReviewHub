package integration_test

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"os"
	"testing"
	"time"

	_ "github.com/lib/pq"
	"github.com/pressly/goose/v3"
	"github.com/stretchr/testify/require"
	"go.uber.org/zap"

	"github.com/RozmiDan/gameReviewHub/internal/entity"
	postgres_storage "github.com/RozmiDan/gameReviewHub/internal/repo/postgre"
	"github.com/RozmiDan/gameReviewHub/pkg/postgres"
)

const (
	dsn        = "postgres://test:test@localhost:5432/testdb?sslmode=disable"
	migrations = "../db/migrations"
)

func TestMain(m *testing.M) {
	deadline := time.Now().Add(time.Second)
	for {
		db, err := sql.Open("postgres", dsn)
		if err == nil {
			if err = db.PingContext(context.Background()); err == nil {
				db.Close()
				break
			}
		}
		if time.Now().After(deadline) {
			log.Fatalf("database did not become ready in time: %v", err)
		}
		time.Sleep(500 * time.Millisecond)
	}

	db, err := sql.Open("postgres", dsn)
	if err != nil {
		log.Fatalf("failed to open db: %v", err)
	}
	defer db.Close()

	goose.SetTableName("goose_db_version")
	if err := goose.SetDialect("postgres"); err != nil {
		log.Fatalf("goose: %v", err)
	}
	if err := goose.Up(db, migrations); err != nil {
		log.Fatalf("goose up: %v", err)
	}

	os.Exit(m.Run())
}

func mustConn(t *testing.T) *postgres.Postgres {
	conn, err := postgres.New(dsn)
	require.NoError(t, err)
	return conn
}

func cleanupTables(t *testing.T, conn *postgres.Postgres) {
	_, err := conn.Pool.Exec(context.Background(),
		`TRUNCATE comments, games RESTART IDENTITY CASCADE;`)
	require.NoError(t, err)
}

// TestAddComment_GameNotFound проверяет ошибку при вставке в несуществующую игру
func TestAddComment_GameNotFound(t *testing.T) {
	conn := mustConn(t)
	repo := postgres_storage.New(conn, zap.NewNop())
	cleanupTables(t, conn)

	ctx := context.Background()
	// не создаём игру
	id, err := repo.AddComment(ctx, "00000000-0000-0000-0000-000000000002", "11111111-1111-1111-1111-111111111111", "text")
	require.Empty(t, id)
	require.ErrorIs(t, err, entity.ErrGameNotFound)
}

// TestGetCommentsGame_Empty проверяет, что для игры без комментариев вернётся пустой список
func TestGetCommentsGame_Empty(t *testing.T) {
	conn := mustConn(t)
	repo := postgres_storage.New(conn, zap.NewNop())
	cleanupTables(t, conn)

	ctx := context.Background()
	// создаём игру
	gameID := "00000000-0000-0000-0000-000000000003"
	_, err := conn.Pool.Exec(ctx,
		`INSERT INTO games(id,name,genre,creator,description,release_date)
		   VALUES($1,'G','G','G','G','2020-01-01')`, gameID)
	require.NoError(t, err)

	comments, err := repo.GetCommentsGame(ctx, gameID, 10, 0)
	require.NoError(t, err)
	require.Len(t, comments, 0)
}

// TestGetCommentsGame_Pagination проверяет limit/offset (страницы)
func TestGetCommentsGame_Pagination(t *testing.T) {
	conn := mustConn(t)
	repo := postgres_storage.New(conn, zap.NewNop())
	cleanupTables(t, conn)

	ctx := context.Background()
	// создаём игру
	gameID := "00000000-0000-0000-0000-000000000004"
	_, err := conn.Pool.Exec(ctx,
		`INSERT INTO games(id,name,genre,creator,description,release_date)
		   VALUES($1,'G','G','G','G','2020-01-01')`, gameID)
	require.NoError(t, err)

	// вручную вставляем 5 комментариев с разным created_at
	for i := 1; i <= 5; i++ {
		text := fmt.Sprintf("c%d", i)
		created := time.Now().Add(time.Duration(i) * time.Second)
		_, err := conn.Pool.Exec(ctx,
			`INSERT INTO comments(game_id, user_id, text, created_at)
			   VALUES($1, $2, $3, $4)`,
			gameID,
			"22222222-2222-2222-2222-222222222222",
			text,
			created,
		)
		require.NoError(t, err)
	}

	// В БД от newest к oldest: c5, c4, c3, c2, c1

	// страница 0, limit=2 → [c5, c4]
	page0, err := repo.GetCommentsGame(ctx, gameID, 2, 0)
	require.NoError(t, err)
	require.Len(t, page0, 2)
	require.Equal(t, "c5", page0[0].Text)
	require.Equal(t, "c4", page0[1].Text)

	page1, err := repo.GetCommentsGame(ctx, gameID, 2, 1)
	require.NoError(t, err)
	require.Len(t, page1, 2)
	require.Equal(t, "c3", page1[0].Text)
	require.Equal(t, "c2", page1[1].Text)

	page2, err := repo.GetCommentsGame(ctx, gameID, 2, 2)
	require.NoError(t, err)
	require.Len(t, page2, 1)
	require.Equal(t, "c1", page2[0].Text)
}

func TestAddGameTopic_AutoID(t *testing.T) {
	conn := mustConn(t)
	repo := postgres_storage.New(conn, zap.NewNop())
	cleanupTables(t, conn)

	ctx := context.Background()
	g := &entity.Game{
		Name:        "TestGameAuto",
		Genre:       "Test",
		Creator:     "Tester",
		Description: "Autogenerated ID",
		ReleaseDate: time.Date(2021, 1, 2, 0, 0, 0, 0, time.UTC),
	}

	id, err := repo.AddGameTopic(ctx, g)
	require.NoError(t, err)
	require.NotEmpty(t, id)

	// проверяем, что запись действительно есть
	var count int
	err = conn.Pool.QueryRow(ctx,
		`SELECT count(*) FROM games WHERE id = $1 AND name = $2`,
		id, g.Name,
	).Scan(&count)
	require.NoError(t, err)
	require.Equal(t, 1, count)
}

// TestAddGameTopic_CustomID: вставка с явным ID
func TestAddGameTopic_CustomID(t *testing.T) {
	conn := mustConn(t)
	repo := postgres_storage.New(conn, zap.NewNop())
	cleanupTables(t, conn)

	ctx := context.Background()
	customID := "aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"
	g := &entity.Game{
		ID:          customID,
		Name:        "TestGameCustom",
		Genre:       "Test",
		Creator:     "Tester",
		Description: "Custom ID",
		ReleaseDate: time.Date(2022, 2, 3, 0, 0, 0, 0, time.UTC),
	}

	id, err := repo.AddGameTopic(ctx, g)
	require.NoError(t, err)
	require.Equal(t, customID, id)

	// убеждаемся, что запись есть
	var name string
	err = conn.Pool.QueryRow(ctx,
		`SELECT name FROM games WHERE id = $1`, customID,
	).Scan(&name)
	require.NoError(t, err)
	require.Equal(t, g.Name, name)
}

// TestAddGameTopic_DuplicateName: повторная вставка по тому же имени должна вернуть ErrGameAlreadyExists
func TestAddGameTopic_DuplicateName(t *testing.T) {
	conn := mustConn(t)
	repo := postgres_storage.New(conn, zap.NewNop())
	cleanupTables(t, conn)

	ctx := context.Background()
	g1 := &entity.Game{
		Name:        "TestGameDup",
		Genre:       "Test",
		Creator:     "Tester",
		Description: "First insert",
		ReleaseDate: time.Date(2023, 3, 4, 0, 0, 0, 0, time.UTC),
	}
	// первая вставка
	id1, err := repo.AddGameTopic(ctx, g1)
	require.NoError(t, err)
	require.NotEmpty(t, id1)

	// вторая — с тем же именем
	g2 := &entity.Game{
		Name:        g1.Name,
		Genre:       "Test2",
		Creator:     "Tester2",
		Description: "Second insert",
		ReleaseDate: time.Date(2024, 4, 5, 0, 0, 0, 0, time.UTC),
	}
	id2, err := repo.AddGameTopic(ctx, g2)
	require.Empty(t, id2)
	require.ErrorIs(t, err, entity.ErrGameAlreadyExists)
}

// TestGetGameTopic_Success проверяет, что после вставки игры
// GetGameTopic вернёт все её поля.
func TestGetGameTopic_Success(t *testing.T) {
	conn := mustConn(t)
	repo := postgres_storage.New(conn, zap.NewNop())
	cleanupTables(t, conn)

	ctx := context.Background()
	gameID := "11111111-1111-1111-1111-111111111111"
	// Вставляем руками
	_, err := conn.Pool.Exec(ctx, `
		INSERT INTO games (id, name, genre, creator, description, release_date)
		VALUES ($1, $2, $3, $4, $5, $6)
	`, gameID, "MyGame", "GenreX", "CreatorY", "Some description",
		time.Date(2020, 5, 6, 0, 0, 0, 0, time.UTC))
	require.NoError(t, err)

	// Собственно вызов
	game, err := repo.GetGameTopic(ctx, gameID)
	require.NoError(t, err)

	// Проверяем
	require.Equal(t, gameID, game.ID)
	require.Equal(t, "MyGame", game.Name)
	require.Equal(t, "GenreX", game.Genre)
	require.Equal(t, "CreatorY", game.Creator)
	require.Equal(t, "Some description", game.Description)
	require.Equal(t, time.Date(2020, 5, 6, 0, 0, 0, 0, time.UTC), game.ReleaseDate)
}

// TestGetGameTopic_NotFound проверяет, что при запросе несуществующего game_id
// возвращается ErrGameNotFound.
func TestGetGameTopic_NotFound(t *testing.T) {
	conn := mustConn(t)
	repo := postgres_storage.New(conn, zap.NewNop())
	cleanupTables(t, conn)

	ctx := context.Background()
	nonexistentID := "22222222-2222-2222-2222-222222222222"

	_, err := repo.GetGameTopic(ctx, nonexistentID)
	require.ErrorIs(t, err, entity.ErrGameNotFound)
}
